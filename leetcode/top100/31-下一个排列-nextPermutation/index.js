/*
 * @Author: xxx
 * @Date: 2020-12-24 22:17:41
 * @LastEditors: xxx
 * @LastEditTime: 2020-12-27 11:16:02
 * @Description: 文件功能描述
 */

// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
// 必须 原地 修改，只允许使用额外常数空间。
// 示例 1：
// 输入：nums = [1,2,3]
// 输出：[1,3,2]
// 示例 2：
// 输入：nums = [3,2,1]
// 输出：[1,2,3]
// 示例 3：
// 输入：nums = [1,1,5]
// 输出：[1,5,1]
// 示例 4：
// 输入：nums = [1]
// 输出：[1]

// 思路：
// 注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：

// 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。

// 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

// 以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：

// 我们能找到的符合条件的一对「较小数」与「较大数」的组合为 22 与 33，满足「较小数」尽量靠右，而「较大数」尽可能小。

// 当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。

// 具体地，我们这样描述该算法，对于长度为 nn 的排列 aa：

// 首先从后向前查找第一个顺序对 (i,i+1)(i,i+1)，满足 a[i] < a[i+1]a[i]<a[i+1]。这样「较小数」即为 a[i]a[i]。此时 [i+1,n)[i+1,n) 必然是下降序列。

// 如果找到了顺序对，那么在区间 [i+1,n)[i+1,n) 中从后向前查找第一个元素 jj 满足 a[i] < a[j]a[i]<a[j]。这样「较大数」即为 a[j]a[j]。

// 交换 a[i]a[i] 与 a[j]a[j]，此时可以证明区间 [i+1,n)[i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n)[i+1,n) 使其变为升序，而无需对该区间进行排序。



var nextPermutation = function(nums) {
    let len = nums.length 
    let idx = len - 1
    let changeIdx = 0
    // 找到待交换的位置
    while(idx ){
        if(nums[idx - 1] < nums[idx]) break
        idx--
    }
    // idx为0说明整个数组为升序（左到右），即为最大值了，所以直接返回最小值
    if(idx === 0) return nums.reverse()
    // 找到最小交换值
    for(let i = len; i > idx; i--){
        if(nums[i]>nums[idx]){
            changeIdx = i
            [nums[changeIdx],nums[idx]] = [nums[idx],nums[changeIdx]]
        }
    }
    while (idx < len) {                            
        [nums[idx], nums[len]] = [nums[idx], nums[len]];
        idx++;
        len--;
    }
    return nums
};
function nextPermutation(nums) {
    let i = nums.length - 2;                   // 向左遍历，i从倒数第二开始是为了nums[i+1]要存在
    while (i >= 0 && nums[i] >= nums[i + 1]) { // 寻找第一个小于右邻居的数
        i--;
    }
    if (i >= 0) {                             // 这个数在数组中存在，从它身后挑一个数，和它换
        let j = nums.length - 1;                // 从最后一项，向左遍历
        while (j >= 0 && nums[j] <= nums[i]) {  // 寻找第一个大于 nums[i] 的数
            j--;
        }
        [nums[i], nums[j]] = [nums[j], nums[i]]; // 两数交换，实现变大
    }
    // 如果 i = -1，说明是递减排列，如 3 2 1，没有下一排列，直接翻转为最小排列：1 2 3
    let l = i + 1;           
    let r = nums.length - 1;
    while (l < r) {                            // i 右边的数进行翻转，使得变大的幅度小一些
        [nums[l], nums[r]] = [nums[r], nums[l]];
        l++;
        r--;
    }
}


